<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Projeto II</title>
    <style>
        body {
            margin: 0;
            color: #444;
            background: #f6f6f6;
            font-family: ArcadeFont;
        }

        @font-face {
        font-family: ArcadeFont;
        src: url(fonts/PressStart2P-Regular.ttf);
        }

        p{
            color:#EBDB93;
        }
    </style>
</head>

<body>
    <!-- The BODY will hold the output -->
    <div style="position: absolute;right:40px"><p>Score: <span id='score'>0</span></p></div>
    <script type="module">
        import * as THREE from './libs/three.module.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';
        import { OrbitControls } from './libs/OrbitControls.js';

        // THREEJS RELATED VARIABLES
        let scene, renderer, camera;

        //dom for score
        let score=document.querySelector("#score")

        // 3D Models
        let chicken, wallG1, Tree3, rearChicken,keytest,trueorfalse,wing1,wing2,car,car2,car3,atrelado3,atrelado2,atrelado,trueorfalseAtrelado, littleChicken;

        let colorCar=""


        // Directional light movement
        let lightParams = {
            object: null,
            helper: null,
            helperShadow: null,
            curve: null,
            position: 0,
        };

        window.onload = function init() {
            // set up the scene, the camera and the renderer
            createScene();

            // add the objects
            createRoadGarden();
            createChicken();
            createTrees();
            createWalls();
            createCar();
            createCar2();
            createCar3();
            createLittleChicken();

            // add the lights
            createLights();

            // set the animation function
            renderer.setAnimationLoop(render);
        }

        //INIT THREE JS, SCREEN, SCENE, CAMERA AND MOUSE EVENTS
        function createScene() {
            // create an empty scene, that will hold all our elements such as objects, cameras and lights
            scene = new THREE.Scene();

            scene.fog = new THREE.Fog(0xf7d9aa, 100);

            // create a camera, which defines where we're looking at
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100);
            camera.position.set(0,10,20)


            // create a render and set the size
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // configure renderer clear color
            renderer.setClearColor("#98BFDE");

            /*****************************
            * SHADOWS 
            ****************************/
            // enable shadow rendering
            renderer.shadowMap.enabled = true;

            // add the output of the renderer to the DIV with id "world"
            document.body.appendChild(renderer.domElement);


            const controls = new OrbitControls(camera, renderer.domElement);


            // listen to the screen: if the user resizes it we have to update the camera and the renderer size
            window.addEventListener('resize', handleWindowResize, false);

        }

        function handleWindowResize() {
            // update height and width of the renderer and the camera
            const HEIGHT = window.innerHeight;
            const WIDTH = window.innerWidth;
            renderer.setSize(WIDTH, HEIGHT);
            camera.aspect = WIDTH / HEIGHT;
            camera.updateProjectionMatrix();
        }

        function createLights() {
            // A hemisphere light is a gradient colored light 
            // Parameters: sky color, ground color, intensity of the light
            let hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, 0.9);
            scene.add(hemisphereLight);

            // A directional light shines from a specific direction. 
            // It acts like the sun, that means that all the rays produced are parallel.
            lightParams.object = new THREE.DirectionalLight(0xffffff, .9);
            lightParams.object.position.set(10, 5, 20);

            /**************
             * SHADOWS
             **************/
            lightParams.object.castShadow = true;
            // augment the visible volume of the projected shadow
            // console.log(lightParams.object.shadow.camera)
            // lightParams.object.shadow.camera.left = -50;
            // lightParams.object.shadow.camera.right = 50;
            // lightParams.object.shadow.camera.top = 50;
            // lightParams.object.shadow.camera.bottom = -50;

            // make the hemisphere light FOLLOW THE object
            console.log(chicken)
            lightParams.object.target = chicken.children[8];
    
            // to activate the lights, just add them to the scene
            scene.add(lightParams.object);

            /*HELPERS*/
            // directional light helper
            lightParams.helper = new THREE.DirectionalLightHelper(lightParams.object, 5);
            scene.add(lightParams.helper);

            //HELPER to visualize the SHADOW area of influence
            lightParams.helperShadow = new THREE.CameraHelper(lightParams.object.shadow.camera);
            scene.add(lightParams.helperShadow);
        }

        function createRoadGarden() {
            const geometries = [];

            const colorBrown = new THREE.Color(0x505365);
            const colorGreen = new THREE.Color(0xADD94F);

            const gardenRectangle = new THREE.BoxGeometry( 87, 0.080, 4.380);
            gardenRectangle.translate(0,0,13.343)

            const colorsGarden = [];
            for (let i = 0; i < gardenRectangle.attributes.position.count; i++)
                colorsGarden.push(colorGreen.r, colorGreen.g, colorGreen.b);

            gardenRectangle.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsGarden), 3));

            geometries.push(gardenRectangle);

            const gardenRectangle1 = new THREE.BoxGeometry( 87, 0.080, 3.280);
            gardenRectangle1.translate(0,0,0.270)

            gardenRectangle1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsGarden), 3));
            
            geometries.push(gardenRectangle1); 

            const gardenRectangle2 = new THREE.BoxGeometry( 87, 0.080, 3.160);
            gardenRectangle2.translate(0,0,-12.247)

            gardenRectangle2.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsGarden), 3));
            
            geometries.push(gardenRectangle2);

            /*SET ROAD*/

            const roadRectangle=new THREE.BoxGeometry(87,0.080,9.280);
            roadRectangle.translate(0,0,6.531)

            const colorsRoad = [];
            for (let i = 0; i < roadRectangle.attributes.position.count; i++)
                colorsRoad.push(colorBrown.r, colorBrown.g, colorBrown.b);

            roadRectangle.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsRoad), 3));
            geometries.push(roadRectangle)

            const roadRectangle1=new THREE.BoxGeometry(87,0.080,9.280);
            roadRectangle1.translate(0,0,-6.007)

            roadRectangle1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsRoad), 3));
            
            geometries.push(roadRectangle1)


            const cenarioElements = BufferGeometryUtils.mergeBufferGeometries(geometries);
            const cenario = new THREE.Mesh(
                cenarioElements,
                new THREE.MeshPhongMaterial({ vertexColors: true })
            )
            scene.add(cenario)

            /*****************************
            * SHADOWS 
            ****************************/
            // allow the sea to receive shadows
            cenario.receiveShadow = true;
        }

        function createChicken() {
            // chicken =  new THREE.Group();

            chicken =  new THREE.Object3D();

            //body

            //foots

            const foot = new THREE.Mesh(
            new THREE.BoxGeometry(0.190,0.060,0.190),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            foot.position.x=-0.195
            foot.position.y=0.080
            foot.position.z=12.1
            chicken.add(foot)
            console.log(foot);

            const foot1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.190,0.060,0.190),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F })
            )
            foot1.position.x=0.197
            foot1.position.y=0.080
            foot1.position.z=12.1
            chicken.add(foot1)

            //fingers foot
            const finger1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.063,0.060,0.113),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F })
            )
            finger1.position.x=0.132
            finger1.position.y=0.080
            finger1.position.z=11.949
            chicken.add(finger1)

            const finger2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.063,0.060,0.113),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F })
            )
            finger2.position.x=-0.258
            finger2.position.y=0.080
            finger2.position.z=11.949
            chicken.add(finger2)

            const finger3 = new THREE.Mesh(
            new THREE.BoxGeometry(0.063,0.060,0.113),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F })
            )
            finger3.position.x=-0.132
            finger3.position.y=0.080
            finger3.position.z=11.949
            chicken.add(finger3)

            const finger4 = new THREE.Mesh(
            new THREE.BoxGeometry(0.063,0.060,0.113),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F })
            )
            finger4.position.x=0.262
            finger4.position.y=0.080
            finger4.position.z=11.949
            chicken.add(finger4)

            //legs
            const legs1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.075,0.250,0.075),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F })
            )
            legs1.position.x=-0.191
            legs1.position.y=0.234
            legs1.position.z=12.1
            chicken.add(legs1)

            const legs2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.075,0.250,0.075),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F })
            )
            legs2.position.x=0.194
            legs2.position.y=0.234
            legs2.position.z=12.1
            chicken.add(legs2)

            //body

            const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.530,0.420,0.810),
            new THREE.MeshPhongMaterial({ color:0xFFFFFF })
            )
            body.position.x=0.009
            body.position.y=0.571
            body.position.z=12.068
            body.name = 'body'
            chicken.add(body)
            

            //head

            const head = new THREE.Mesh(
            new THREE.BoxGeometry(0.530,0.530,0.500),
            new THREE.MeshPhongMaterial({ color:0xFFFFFF })
            )
            head.position.x=0.011
            head.position.y=1.043
            head.position.z=11.94
            chicken.add(head)

            //mouth

            const mouth = new THREE.Mesh(
            new THREE.BoxGeometry(0.150,0.130,0.220),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F })
            )
            mouth.position.x=0.002
            mouth.position.y=1.025
            mouth.position.z=11.562
            chicken.add(mouth)

            const mouth1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.130,0.130,0.130),
            new THREE.MeshPhongMaterial({ color:0xEF3146 })
            )
            mouth1.position.x=0.001
            mouth1.position.y=0.897
            mouth1.position.z=11.608
            chicken.add(mouth1)

            //eyes

            const eye1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.070,0.070,0.070),
            new THREE.MeshPhongMaterial({ color:0x000000 })
            )
            eye1.position.x=0.247
            eye1.position.y=1.171
            eye1.position.z=11.825
            chicken.add(eye1)

            const eye2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.070,0.070,0.070),
            new THREE.MeshPhongMaterial({ color:0x000000 })
            )
            eye2.position.x=-0.221
            eye2.position.y=1.171
            eye2.position.z=11.825
            chicken.add(eye2)

            //wings 

            wing1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.060,0.230,0.430),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6})
            )
            wing1.position.x=-0.283
            wing1.position.y=0.566
            wing1.position.z=12.066
            chicken.add(wing1)

            wing2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.060,0.230,0.430),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6})
            )
            wing2.position.x=0.309
            wing2.position.y=0.566
            wing2.position.z=12.066
            chicken.add(wing2)

            //rear 

            rearChicken = new THREE.Mesh(
            new THREE.BoxGeometry(0.070,0.070,0.110),
            new THREE.MeshPhongMaterial({ color:0xEF3146})
            )
            rearChicken.position.x=0.017
            rearChicken.position.y=0
            rearChicken.position.z=0.430

            const rear1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.070,0.070,0.070),
            new THREE.MeshPhongMaterial({ color:0xEF3146})
            )
            rear1.position.y=0.070
            rear1.position.x=0.00
            rear1.position.z=-0.02
            rearChicken.add(rear1)
            body.add(rearChicken)

            //upHead

            const upHead = new THREE.Mesh(
            new THREE.BoxGeometry(0.080,0.070,0.220),
            new THREE.MeshPhongMaterial({ color:0xEF3146 })
            )
            upHead.position.x=0.008
            upHead.position.y=1.334
            upHead.position.z=11.942
            chicken.add(upHead)
            

            let axesBody = new THREE.AxesHelper(20);
            body.add(axesBody);
            

            scene.add(chicken)

            chicken.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            
        }

        function createTrees() {
           // set coolrs tree 
           const colorBrownTree = new THREE.Color(0x412320);
            const colorGreenTree = new THREE.Color(0x85B120);

            const tree1=[]
            
            // TRUNK: 1st geometry
            const trunk1 = new THREE.BoxGeometry(0.750, 1.0, 0.750);
            trunk1.translate(-8.722,0.544,-11.624)
            
            // LEVEL1: 2nd geometry
            const levelTree1 = new THREE.BoxGeometry(1.560, 1.900, 1.320);
            levelTree1.translate(-8.764, 1.948, -11.646); // translate the geometry


            const colorsTrunkS = [];
            for (let i = 0; i < trunk1.attributes.position.count; i++)
                colorsTrunkS.push(colorBrownTree.r, colorBrownTree.g, colorBrownTree.b);

            trunk1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkS), 3));

            const colorsLeavesS = [];
            for (let i = 0; i < levelTree1.attributes.position.count; i++)
                colorsLeavesS.push(colorGreenTree.r, colorGreenTree.g, colorGreenTree.b);

            levelTree1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesS), 3));
            tree1.push(trunk1)
            tree1.push(levelTree1)

            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry = BufferGeometryUtils.mergeBufferGeometries(tree1);
            const Tree = new THREE.Mesh(TreeGeometry,
                    new THREE.MeshPhongMaterial({ vertexColors: true }))

            scene.add(Tree)

            Tree.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree2=[]
            
            // TRUNK: 1st geometry
            const trunk2 = new THREE.BoxGeometry(0.750, 1.710, 0.750);
            trunk2.translate(1.881,0.881,-11.598)
            tree2.push(trunk2)
            // LEVEL1: 2nd geometry
            const levelTree2 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree2.translate(1.870, 3.794, -11.580); // translate the geometry
            tree2.push(levelTree2)

            const colorsTrunkB = [];
            for (let i = 0; i < trunk2.attributes.position.count; i++)
                colorsTrunkB.push(colorBrownTree.r, colorBrownTree.g, colorBrownTree.b);

            trunk2.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            const colorsLeavesB = [];
            for (let i = 0; i < levelTree2.attributes.position.count; i++)
                colorsLeavesB.push(colorGreenTree.r, colorGreenTree.g, colorGreenTree.b);

            levelTree2.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry2 = BufferGeometryUtils.mergeBufferGeometries(tree2);
            const Tree2 = new THREE.Mesh(TreeGeometry2,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree2)

            Tree2.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree3=[]
            
            // TRUNK: 1st geometry
            const trunk3 = new THREE.BoxGeometry(0.750,1.000, 0.750);
            trunk3.translate(-9.051,0.457,0.000)
            tree3.push(trunk3)
            // LEVEL1: 2nd geometry
            const levelTree3 = new THREE.BoxGeometry(1.560, 1.900, 1.320);
            levelTree3.translate(-9.030, 1.785, 0.000); // translate the geometry

            trunk3.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkS), 3));
            
            levelTree3.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesS), 3));

            tree3.push(levelTree3)
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry3 = BufferGeometryUtils.mergeBufferGeometries(tree3);
            Tree3 = new THREE.Mesh(TreeGeometry3,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree3)

            Tree3.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree4=[]
            
            // TRUNK: 1st geometry
            const trunk4 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk4.translate(3.330,0.873,0.000)
            tree4.push(trunk4)
            // LEVEL1: 2nd geometry
            const levelTree4 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree4.translate(3.383, 3.852, 0.037); // translate the geometry
            tree4.push(levelTree4)

            trunk4.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree4.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry4 = BufferGeometryUtils.mergeBufferGeometries(tree4);
            const Tree4 = new THREE.Mesh(TreeGeometry3,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree4)

            Tree4.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });


            const tree5=[]
            
            // TRUNK: 1st geometry
            const trunk5 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk5.translate(9.059,0.873,0.000)
            tree5.push(trunk5)
            // LEVEL1: 2nd geometry
            const levelTree5 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree5.translate(9.031, 3.852, 0.000); // translate the geometry
            tree5.push(levelTree5)

            trunk5.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree5.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry5 = BufferGeometryUtils.mergeBufferGeometries(tree5);
            const Tree5 = new THREE.Mesh(TreeGeometry5,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree5)

            Tree5.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree6=[]
            
            // TRUNK: 1st geometry
            const trunk6 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk6.translate(-11.261,0.685,11.838)
            tree6.push(trunk6)
            // LEVEL1: 2nd geometry
            const levelTree6 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree6.translate(-11.240, 3.580, 11.810); // translate the geometry
            tree6.push(levelTree6)

            trunk6.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));
            
            levelTree6.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry6 = BufferGeometryUtils.mergeBufferGeometries(tree6);
            const Tree6 = new THREE.Mesh(TreeGeometry6,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree6)

            Tree6.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree7=[]
            
            // TRUNK: 1st geometry
            const trunk7 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk7.translate(-6.740,0.901,13.285)
            tree7.push(trunk7)
            // LEVEL1: 2nd geometry
            const levelTree7 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree7.translate(-6.787, 3.796, 13.275); // translate the geometry
            tree7.push(levelTree7)

            trunk7.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree7.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry7 = BufferGeometryUtils.mergeBufferGeometries(tree7);
            const Tree7 = new THREE.Mesh(TreeGeometry7,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree7)

            Tree7.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree8=[]
            
            // TRUNK: 1st geometry
            const trunk8 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk8.translate(8.095,0.861,-12.282)
            tree8.push(trunk8)
            // LEVEL1: 2nd geometry
            const levelTree8 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree8.translate(8.060, 3.728, -12.154); // translate the geometry
            tree8.push(levelTree8)

            trunk8.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree8.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry8 = BufferGeometryUtils.mergeBufferGeometries(tree8);
            const Tree8 = new THREE.Mesh(TreeGeometry8,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree8)

            Tree8.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree9=[]
            
            // TRUNK: 1st geometry
            const trunk9 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk9.translate(7.212,0.919,12.766)
            tree9.push(trunk9)
            // LEVEL1: 2nd geometry
            const levelTree9 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree9.translate(7.176, 3.834, 12.769); // translate the geometry
            tree9.push(levelTree9)

            trunk9.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree9.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry9 = BufferGeometryUtils.mergeBufferGeometries(tree9);
            const Tree9 = new THREE.Mesh(TreeGeometry9,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree9)

            Tree9.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });


            const tree10=[]
            // TRUNK: 1st geometry
            const trunk10 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk10.translate(-15.259,0.887,0.000)
            tree10.push(trunk10)
            // LEVEL1: 2nd geometry
            const levelTree10 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree10.translate(-15.244, 3.763, 0.000); // translate the geometry
            tree10.push(levelTree10)

            trunk10.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree10.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry10 = BufferGeometryUtils.mergeBufferGeometries(tree10);
            const Tree10 = new THREE.Mesh(TreeGeometry10,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree10)

            Tree10.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree11=[]
            // TRUNK: 1st geometry
            const trunk11 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk11.translate(-22.259,0.887,0.000)
            tree11.push(trunk11)
            // LEVEL1: 2nd geometry
            const levelTree11 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree11.translate(-22.244, 3.763, 0.000); // translate the geometry
            tree11.push(levelTree11)

            trunk11.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree11.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry11 = BufferGeometryUtils.mergeBufferGeometries(tree11);
            const Tree11 = new THREE.Mesh(TreeGeometry11,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree11)

            Tree11.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree12=[]
            // TRUNK: 1st geometry
            const trunk12 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk12.translate(20.259,0.887,0.000)
            tree12.push(trunk12)
            // LEVEL1: 2nd geometry
            const levelTree12 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree12.translate(20.244, 3.763, 0.000); // translate the geometry
            tree12.push(levelTree12)

            trunk12.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree12.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry12 = BufferGeometryUtils.mergeBufferGeometries(tree12);
            const Tree12 = new THREE.Mesh(TreeGeometry12,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree12)

            Tree12.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const tree13=[]
            
            // TRUNK: 1st geometry
            const trunk13 = new THREE.BoxGeometry(0.750, 1.710, 0.750);
            trunk13.translate(22.881,0.881,-11.598)
            tree13.push(trunk13)
            // LEVEL1: 2nd geometry
            const levelTree13 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree13.translate(22.870, 3.794, -11.580); // translate the geometry
            tree13.push(levelTree13)

            trunk13.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree13.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry13 = BufferGeometryUtils.mergeBufferGeometries(tree13);
            const Tree13 = new THREE.Mesh(TreeGeometry13,
                new THREE.MeshPhongMaterial({ vertexColors: true }))
            scene.add(Tree13)

            Tree13.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

        }

        function createWalls(){
            wallG1 =  new THREE.Group();
            const wall1 = new THREE.Mesh(
            new THREE.BoxGeometry(100.000,-3.720,1.000),
            new THREE.MeshPhongMaterial({ color:0x757575 }),
            )
            wall1.position.x=0
            wall1.position.y=0.667
            wall1.position.z=-14.316
            wallG1.add(wall1)
            scene.add(wallG1)

            wallG1.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const wallG2 =  new THREE.Group();
            const wall2 = new THREE.Mesh(
            new THREE.BoxGeometry(100.000,-3.720,1.000),
            new THREE.MeshPhongMaterial({ color:0x757575 }),
            )
            wall2.position.x=0
            wall2.position.y=0.667
            wall2.position.z=16.033
            wallG2.add(wall2)
            scene.add(wallG2)

            wallG1.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        }

        function createCar(){
            car= new THREE.Group()
            atrelado= new THREE.Group()
            

            //RODAS DO CARRO
            const wheel1 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel1.position.x = 3.207
            wheel1.position.y = 0.420
            wheel1.position.z = 4.569
            wheel1.rotateX(THREE.Math.degToRad(90))
            car.add(wheel1)

            const wheel2 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel2.position.x = 3.207
            wheel2.position.y = 0.420
            wheel2.position.z = 6.547
            wheel2.rotateX(THREE.Math.degToRad(90))
            car.add(wheel2)
            
            const wheel3 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel3.position.x = 0.645
            wheel3.position.y = 0.420
            wheel3.position.z = 4.439
            wheel3.rotateX(THREE.Math.degToRad(90))
            car.add(wheel3)
            
            const wheel4 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel4.position.x = 0.645
            wheel4.position.y = 0.420 
            wheel4.position.z = 6.547
            wheel4.rotateX(THREE.Math.degToRad(90))
            car.add(wheel4)

            //farois do carro
            const far1 =new THREE.Mesh( new THREE.SphereGeometry( 0.2, 20, 10 ),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            far1.position.x = 4.2
            far1.position.y = 1.28
            far1.position.z = 5
            car.add(far1)

            const far2 =new THREE.Mesh( new THREE.SphereGeometry( 0.2, 20, 10 ),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            far2.position.x = 4.2
            far2.position.y = 1.28
            far2.position.z = 6.1
            car.add(far2)



            //Rodas do atrelado
            
            const wheel5 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000}),
            )
            wheel5.position.x = -2.647
            wheel5.position.y = 0.420
            wheel5.position.z = 6.547
            wheel5.rotateX(THREE.Math.degToRad(90))
            atrelado.add(wheel5)
            
            const wheel6 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel6.position.x = -2.647
            wheel6.position.y = 0.420
            wheel6.position.z = 4.439
            wheel6.rotateX(THREE.Math.degToRad(90))

            atrelado.add(wheel6)



            //Cubos do carro

            const cube1 =new THREE.Mesh( new THREE.BoxGeometry(4.340, 1.400, 1.960),
            new THREE.MeshPhongMaterial({ color:0x001FD5 }),
            )
            cube1.position.x = 1.991
            cube1.position.y = 1.087
            cube1.position.z = 5.533
            cube1.name='capot'
            car.add(cube1)

            const cube2 =new THREE.Mesh( new THREE.BoxGeometry(2.554, 1.250, 1.960),
            new THREE.MeshPhongMaterial({ color:0x616870 }),
            )
            cube2.position.x = 1.627
            cube2.position.y = 2.384
            cube2.position.z = 5.533
            car.add(cube2)

            //Cubo do atrelado

            const cube3 =new THREE.Mesh( new THREE.BoxGeometry(3.220, 1.140, 1.960),
            new THREE.MeshPhongMaterial({ color:0x616870 }),
            )
            cube3.position.x = -2.493
            cube3.position.y = 0.968
            cube3.position.z = 5.511
            atrelado.add(cube3)

            const cube4 =new THREE.Mesh( new THREE.BoxGeometry(0.120, 0.240, 0.800),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            cube4.position.x = -4.076
            cube4.position.y = 0.733
            cube4.position.z = 5.541
            atrelado.add(cube4)


            //cilindro do atrelado

            const cld =new THREE.Mesh( new THREE.CylinderGeometry(0.25, 0.25, 0.8),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            cld.position.x = -0.575
            cld.position.y = 0.891
            cld.position.z = 5.561
            cld.rotateZ(THREE.Math.degToRad(90))
            atrelado.add(cld)

            car.add(atrelado)
            
            car.position.x=-20
            //car.position.x=25
            //Criar geometria do carro
            scene.add(car)
            console.log(car);
            car.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            
        }

        function createCar2(){
            car2= new THREE.Group()
            atrelado2= new THREE.Group()
            

            //RODAS DO CARRO
            const wheel1 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel1.position.x = 3.207
            wheel1.position.y = 0.420
            wheel1.position.z = 4.569
            wheel1.rotateX(THREE.Math.degToRad(90))
            car2.add(wheel1)

            const wheel2 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel2.position.x = 3.207
            wheel2.position.y = 0.420
            wheel2.position.z = 6.547
            wheel2.rotateX(THREE.Math.degToRad(90))
            car2.add(wheel2)
            
            const wheel3 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel3.position.x = 0.645
            wheel3.position.y = 0.420
            wheel3.position.z = 4.439
            wheel3.rotateX(THREE.Math.degToRad(90))
            car2.add(wheel3)
            
            const wheel4 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel4.position.x = 0.645
            wheel4.position.y = 0.420 
            wheel4.position.z = 6.547
            wheel4.rotateX(THREE.Math.degToRad(90))
            car2.add(wheel4)

            //farois do carro
            const far1 =new THREE.Mesh( new THREE.SphereGeometry( 0.2, 20, 10 ),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            far1.position.x = 4.2
            far1.position.y = 1.28
            far1.position.z = 5
            car2.add(far1)

            const far2 =new THREE.Mesh( new THREE.SphereGeometry( 0.2, 20, 10 ),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            far2.position.x = 4.2
            far2.position.y = 1.28
            far2.position.z = 6.1
            car2.add(far2)



            //Rodas do atrelado
            
            const wheel5 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000}),
            )
            wheel5.position.x = -2.647
            wheel5.position.y = 0.420
            wheel5.position.z = 6.547
            wheel5.rotateX(THREE.Math.degToRad(90))
            atrelado2.add(wheel5)
            
            const wheel6 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel6.position.x = -2.647
            wheel6.position.y = 0.420
            wheel6.position.z = 4.439
            wheel6.rotateX(THREE.Math.degToRad(90))

            atrelado2.add(wheel6)



            //Cubos do carro

            const cube1 =new THREE.Mesh( new THREE.BoxGeometry(4.340, 1.400, 1.960),
            new THREE.MeshPhongMaterial({ color:0x001FD5 }),
            )
            cube1.position.x = 1.991
            cube1.position.y = 1.087
            cube1.position.z = 5.533
            cube1.name='capot'
            car2.add(cube1)

            const cube2 =new THREE.Mesh( new THREE.BoxGeometry(2.554, 1.250, 1.960),
            new THREE.MeshPhongMaterial({ color:0x616870 }),
            )
            cube2.position.x = 1.627
            cube2.position.y = 2.384
            cube2.position.z = 5.533
            car2.add(cube2)

            //Cubo do atrelado

            const cube3 =new THREE.Mesh( new THREE.BoxGeometry(3.220, 1.140, 1.960),
            new THREE.MeshPhongMaterial({ color:0x616870 }),
            )
            cube3.position.x = -2.493
            cube3.position.y = 0.968
            cube3.position.z = 5.511
            atrelado2.add(cube3)

            const cube4 =new THREE.Mesh( new THREE.BoxGeometry(0.120, 0.240, 0.800),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            cube4.position.x = -4.076
            cube4.position.y = 0.733
            cube4.position.z = 5.541
            atrelado2.add(cube4)


            //cilindro do atrelado

            const cld =new THREE.Mesh( new THREE.CylinderGeometry(0.25, 0.25, 0.8),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            cld.position.x = -0.575
            cld.position.y = 0.891
            cld.position.z = 5.561
            cld.rotateZ(THREE.Math.degToRad(90))
            atrelado2.add(cld)

            car2.add(atrelado2)
            
            car2.position.x=-44
            car2.position.z=-13.5
            //car.position.x=25
            //Criar geometria do carro
            scene.add(car2)
            console.log(car2);
            car2.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            
            
        }

        function createCar3(){
            car3= new THREE.Group()
            atrelado3= new THREE.Group()
            

            //RODAS DO CARRO
            const wheel1 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel1.position.x = 3.207
            wheel1.position.y = 0.420
            wheel1.position.z = 4.569
            wheel1.rotateX(THREE.Math.degToRad(90))
            car3.add(wheel1)

            const wheel2 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel2.position.x = 3.207
            wheel2.position.y = 0.420
            wheel2.position.z = 6.547
            wheel2.rotateX(THREE.Math.degToRad(90))
            car3.add(wheel2)
            
            const wheel3 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel3.position.x = 0.645
            wheel3.position.y = 0.420
            wheel3.position.z = 4.439
            wheel3.rotateX(THREE.Math.degToRad(90))
            car3.add(wheel3)
            
            const wheel4 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel4.position.x = 0.645
            wheel4.position.y = 0.420 
            wheel4.position.z = 6.547
            wheel4.rotateX(THREE.Math.degToRad(90))
            car3.add(wheel4)

            //farois do carro
            const far1 =new THREE.Mesh( new THREE.SphereGeometry( 0.2, 20, 10 ),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            far1.position.x = 4.2
            far1.position.y = 1.28
            far1.position.z = 5
            car3.add(far1)

            const far2 =new THREE.Mesh( new THREE.SphereGeometry( 0.2, 20, 10 ),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            far2.position.x = 4.2
            far2.position.y = 1.28
            far2.position.z = 6.1
            car3.add(far2)



            //Rodas do atrelado
            
            const wheel5 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000}),
            )
            wheel5.position.x = -2.647
            wheel5.position.y = 0.420
            wheel5.position.z = 6.547
            wheel5.rotateX(THREE.Math.degToRad(90))
            atrelado3.add(wheel5)
            
            const wheel6 =new THREE.Mesh( new THREE.CylinderGeometry(0.420, 0.420, 0.400),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            wheel6.position.x = -2.647
            wheel6.position.y = 0.420
            wheel6.position.z = 4.439
            wheel6.rotateX(THREE.Math.degToRad(90))

            atrelado3.add(wheel6)



            //Cubos do carro

            const cube1 =new THREE.Mesh( new THREE.BoxGeometry(4.340, 1.400, 1.960),
            new THREE.MeshPhongMaterial({ color:0x001FD5 }),
            )
            cube1.position.x = 1.991
            cube1.position.y = 1.087
            cube1.position.z = 5.533
            cube1.name='capot'
            car3.add(cube1)

            const cube2 =new THREE.Mesh( new THREE.BoxGeometry(2.554, 1.250, 1.960),
            new THREE.MeshPhongMaterial({ color:0x616870 }),
            )
            cube2.position.x = 1.627
            cube2.position.y = 2.384
            cube2.position.z = 5.533
            car3.add(cube2)

            //Cubo do atrelado

            const cube3 =new THREE.Mesh( new THREE.BoxGeometry(3.220, 1.140, 1.960),
            new THREE.MeshPhongMaterial({ color:0x616870 }),
            )
            cube3.position.x = -2.493
            cube3.position.y = 0.968
            cube3.position.z = 5.511
            atrelado3.add(cube3)

            const cube4 =new THREE.Mesh( new THREE.BoxGeometry(0.120, 0.240, 0.800),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            cube4.position.x = -4.076
            cube4.position.y = 0.733
            cube4.position.z = 5.541
            atrelado3.add(cube4)


            //cilindro do atrelado

            const cld =new THREE.Mesh( new THREE.CylinderGeometry(0.25, 0.25, 0.8),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            cld.position.x = -0.575
            cld.position.y = 0.891
            cld.position.z = 5.561
            cld.rotateZ(THREE.Math.degToRad(90))
            atrelado3.add(cld)

            car3.add(atrelado3)
            
            car3.position.x=36
            car3.position.z=2
            car3.rotateY(THREE.Math.degToRad(180))
            //car.position.x=25
            //Criar geometria do carro
            scene.add(car3)
            car3.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            
            
        }

        function createLittleChicken(){
            littleChicken =  new THREE.Object3D();

            //body

            //foots

            const footLittle = new THREE.Mesh(
            new THREE.BoxGeometry(0.095,0.030,0.095),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            footLittle.position.x=0.183
            footLittle.position.y=0.007
            footLittle.position.z=2.829
            littleChicken.add(footLittle)

            const footLittle1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.095,0.030,0.095),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            footLittle1.position.x=0.000
            footLittle1.position.y=0.007
            footLittle1.position.z=2.829
            littleChicken.add(footLittle1)

            //fingers foot

            const fingerLittle1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.032,0.030,0.057),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            fingerLittle1.position.x=0.214
            fingerLittle1.position.y=0.007
            fingerLittle1.position.z=2.755
            littleChicken.add(fingerLittle1)

            const fingerLittle2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.032,0.030,0.057),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            fingerLittle2.position.x=0.151
            fingerLittle2.position.y=0.007
            fingerLittle2.position.z=2.755
            littleChicken.add(fingerLittle2)

            const fingerLittle3 = new THREE.Mesh(
            new THREE.BoxGeometry(0.032,0.030,0.057),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            fingerLittle3.position.x=0.032
            fingerLittle3.position.y=0.007
            fingerLittle3.position.z=2.755
            littleChicken.add(fingerLittle3)

            const fingerLittle4 = new THREE.Mesh(
            new THREE.BoxGeometry(0.032,0.030,0.057),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            fingerLittle4.position.x=-0.031
            fingerLittle4.position.y=0.007
            fingerLittle4.position.z=2.755
            littleChicken.add(fingerLittle4)

            //legs

            const legLittle1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.037,0.125,0.037),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            legLittle1.position.x=0.183
            legLittle1.position.y=0.084
            legLittle1.position.z=2.832
            littleChicken.add(legLittle1)

            const legLittle2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.037,0.125,0.037),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            legLittle2.position.x=-0.001
            legLittle2.position.y=0.084
            legLittle2.position.z=2.832
            littleChicken.add(legLittle2)

            //body

            const bodyLittle = new THREE.Mesh(
            new THREE.BoxGeometry(0.265,0.210,0.405),
            new THREE.MeshPhongMaterial({ color:0xFFFFFF }),
            )
            bodyLittle.position.x=0.091
            bodyLittle.position.y=0.247
            bodyLittle.position.z=2.853
            littleChicken.add(bodyLittle)

            //wings

            const wingLittle = new THREE.Mesh(
            new THREE.BoxGeometry(0.030,0.115,0.215),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            wingLittle.position.x=0.242
            wingLittle.position.y=0.238
            wingLittle.position.z=2.848
            littleChicken.add(wingLittle)

            const wingLittle1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.030,0.115,0.215),
            new THREE.MeshPhongMaterial({ color:0xD6D6D6 }),
            )
            wingLittle1.position.x=-0.055
            wingLittle1.position.y=0.238
            wingLittle1.position.z=2.848
            littleChicken.add(wingLittle1)

            //rear
            const rearLittle1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.035,0.035,0.070),
            new THREE.MeshPhongMaterial({ color:0xEF3146 }),
            )
            rearLittle1.position.x=0.092
            rearLittle1.position.y=0.236
            rearLittle1.position.z=3.085
            littleChicken.add(rearLittle1)

            const rearLittle2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.035,0.035,0.035),
            new THREE.MeshPhongMaterial({ color:0xEF3146 }),
            )
            rearLittle2.position.x=0.092
            rearLittle2.position.y=0.272
            rearLittle2.position.z=3.071
            littleChicken.add(rearLittle2)

            //head

            const headLittle = new THREE.Mesh(
            new THREE.BoxGeometry(0.265,0.265,0.275),
            new THREE.MeshPhongMaterial({ color:0xFFFFFF }),
            )
            headLittle.position.x=0.093
            headLittle.position.y=0.484
            headLittle.position.z=2.788
            littleChicken.add(headLittle)

            //eyes

            const eyeLittle1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.035,0.035,0.035),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            eyeLittle1.position.x=-0.024
            eyeLittle1.position.y=0.534
            eyeLittle1.position.z=2.744
            littleChicken.add(eyeLittle1)

            const eyeLittle2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.035,0.035,0.035),
            new THREE.MeshPhongMaterial({ color:0x000000 }),
            )
            eyeLittle2.position.x=0.212
            eyeLittle2.position.y=0.534
            eyeLittle2.position.z=2.744
            littleChicken.add(eyeLittle2)

            //upHead

            const upHeadLittle = new THREE.Mesh(
            new THREE.BoxGeometry(0.040,0.035,0.110),
            new THREE.MeshPhongMaterial({ color:0xEF3146 }),
            )
            upHeadLittle.position.x=0.089
            upHeadLittle.position.y=0.630
            upHeadLittle.position.z=2.788
            littleChicken.add(upHeadLittle)

            //Mouth

            const mouthLittle = new THREE.Mesh(
            new THREE.BoxGeometry(0.075,0.065,0.110),
            new THREE.MeshPhongMaterial({ color:0xFC6F3F }),
            )
            mouthLittle.position.x=0.094
            mouthLittle.position.y=0.463
            mouthLittle.position.z=2.597
            littleChicken.add(mouthLittle)

            const mouthLittle1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.065,0.065,0.065),
            new THREE.MeshPhongMaterial({ color:0xEF3146 }),
            )
            mouthLittle1.position.x=0.094
            mouthLittle1.position.y=0.400
            mouthLittle1.position.z=2.620
            littleChicken.add(mouthLittle1)

            littleChicken.rotation.y=THREE.Math.degToRad(160)
            littleChicken.position.x=-1
            littleChicken.position.z=-9
            littleChicken.position.y=0.2

            scene.add(littleChicken)

            littleChicken.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });



            
        }

        function render() {

            //rotate rear chicken
            if (keytest == 1) {
                if(checkColision_Chicken_Egg()){
                    chicken.position.z=0
                }
                else{
				chicken.position.z-=0.05;
                chicken.position.y=0.01
                wing1.rotation.z=5
                wing2.rotation.z=-5
                }
			}
            else{
                wing1.rotation.z=0
                wing2.rotation.z=0
                chicken.position.y=0
            }
            
            if(rearChicken.rotation.y>THREE.Math.degToRad(6)){
                trueorfalse=true
            }
            else if(rearChicken.rotation.y<THREE.Math.degToRad(-6)){
                trueorfalse=false
            }
            rotation(trueorfalse)

            //car move
            if(car.position.x==25){
                car.position.x=-20
                car.position.x+=0.250
            }
            else{
                car.position.x+=0.250
            }
            //rotation atrelado

            if(atrelado.position.y>=0.250){
                trueorfalseAtrelado=true
            }
            else if(atrelado.position.y<=0.150){
                trueorfalseAtrelado=false
            }
            setPositionAtrelado(trueorfalseAtrelado)


            //car.position.x+=0.250


            //  // camera TO object relative offset
            let relativeOffset = new THREE.Vector3(0, 4, 16);//(0,4,16)
            // // updates the offset with the object’s global transformation matrix
            let cameraOffset = relativeOffset.applyMatrix4(chicken.matrixWorld);
            // // updates the camera position with the new offset
            camera.position.copy(cameraOffset)
            // // camera looks at the object’s position
            camera.lookAt(chicken.position);

            
            lightParams.helperShadow.update()
            //console.log(rearChicken.rotation.y);
            

            renderer.render(scene, camera);
        }

        document.addEventListener('keydown', (e) => {

                let key = e.key;

                /*** MOVE TANK BASE ***/
                if (key == "w") {
                    keytest = 1;
                }
                else if(key== "c"){
                    if(colorCar=='blue' || colorCar==''){
                    car.children[6].material= new THREE.MeshPhongMaterial({ color:0x404040 })
                    colorCar='white'
                    }
                    else{
                        car.children[6].material= new THREE.MeshPhongMaterial({ color:0x001DF5 })
                        colorCar='blue'
                    }
                }

        })

        document.addEventListener('keyup', (e) => {
			let key = e.key;

			if (key == "w") {
				keytest = 0;
			}
		

		});

        function rotation(trueorfalse){
            if(trueorfalse==true){
                rearChicken.rotation.y-=0.004;
            }
            else{
                rearChicken.rotation.y+=0.004;
            }
        }

        function setPositionAtrelado(logic){
            if(logic){
                atrelado.position.y-=0.03
            }
            else{
                atrelado.position.y+=0.02
            }
        }

        function checkColision_Chicken_Egg(){
            let chickenBox = new THREE.Box3().setFromObject(chicken);
            let litteChickenBox = new THREE.Box3().setFromObject(littleChicken)
            let collision = chickenBox.intersectsBox(litteChickenBox);
            if (collision) {
                    score.innerHTML=+score.innerHTML+20
					return true;
			}
            else {
                return false
            }
        }

    </script>
</body>

</html>