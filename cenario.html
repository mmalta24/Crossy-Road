<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Pine Trees</title>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to use the complete page */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <!-- HTML body will hold the Output -->
    <script type="module">
        import * as THREE from './libs/three.module.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';

        let camera, scene, renderer;

        // once everything is loaded, we run our Three.js stuff
        window.onload = function init() {
            /*********************
             * SCENE 
             * *******************/
            // create an empty scene, that will hold all our elements such as objects, cameras and lights
            scene = new THREE.Scene();


            /*********************
             * CAMERA 
             * *******************/
            // create a camera, which defines where we're looking at
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100);
            camera.position.x = 2;
            camera.position.y = 2;
            camera.position.z = 5;

            //camera.rotation.set(-32.33,0,0)
            camera.lookAt(0, 2, 0); //points the camera to world point (0,2,0)


            /*********************
             * RENDERER 
             * *******************/
            // create a render and set the size
            renderer = new THREE.WebGLRenderer({ antialias: true }); // aliasing (jagged edges when rendering)
            renderer.setSize(window.innerWidth, window.innerHeight);
            // configure renderer clear color
            renderer.setClearColor("#98BFDE");

            // add the output of the renderer to an HTML element (this case, the body)
            document.body.appendChild(renderer.domElement);
            renderer.setAnimationLoop(render);


            /*******************************************************************************
             * PINETREE = create a single geometry to merge multiple geometries together
             * ****************************************************************************/
            const geometries = [];

            const colorBrown = new THREE.Color(0x505365);
            const colorGreen = new THREE.Color(0xADD94F);

            const gardenRectangle = new THREE.BoxGeometry( 87, 0.080, 4.380);
            gardenRectangle.translate(0,0,13.343)

            

            const colorsGarden = [];
            for (let i = 0; i < gardenRectangle.attributes.position.count; i++)
                colorsGarden.push(colorGreen.r, colorGreen.g, colorGreen.b);

            gardenRectangle.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsGarden), 3));

            geometries.push(gardenRectangle);

            const gardenRectangle1 = new THREE.BoxGeometry( 87, 0.080, 3.280);
            gardenRectangle1.translate(0,0,0.270)

            gardenRectangle1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsGarden), 3));
            
            geometries.push(gardenRectangle1); 

            const gardenRectangle2 = new THREE.BoxGeometry( 87, 0.080, 3.160);
            gardenRectangle2.translate(0,0,-12.247)

            gardenRectangle2.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsGarden), 3));
            
            geometries.push(gardenRectangle2);

            /*SET ROAD*/

            const roadRectangle=new THREE.BoxGeometry(87,0.080,9.280);
            roadRectangle.translate(0,0,6.531)

            const colorsRoad = [];
            for (let i = 0; i < roadRectangle.attributes.position.count; i++)
                colorsRoad.push(colorBrown.r, colorBrown.g, colorBrown.b);

            roadRectangle.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsRoad), 3));
            geometries.push(roadRectangle)

            const roadRectangle1=new THREE.BoxGeometry(87,0.080,9.280);
            roadRectangle1.translate(0,0,-6.007)

            roadRectangle1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsRoad), 3));
            
            geometries.push(roadRectangle1)


            const pineTreeGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries);
            const pineTree = new THREE.Mesh(
                pineTreeGeometry,
                new THREE.MeshBasicMaterial({ vertexColors: true })
            )
            scene.add(pineTree)
            

            /*Chicken*/

            const chicken =  new THREE.Group();

            //Set colors for chicken
            const colorWhiteChicken = new THREE.Color(0xffffff);
            const colorRedChicken = new THREE.Color(0xEF3146);
            const colorBlackChickend=new THREE.Color(0xFC6F3F);
            const colorOrangeChicken=new THREE.Color(0xADD94F);

            //body

            //foots

            const foot = new THREE.Mesh(
            new THREE.BoxGeometry(0.190,0.060,0.190),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F }),
            )
            foot.position.x=-0.195
            foot.position.y=0.5
            foot.position.z=12.1
            chicken.add(foot)
            console.log(foot);

            const foot1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.190,0.060,0.190),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F })
            )
            foot1.position.x=0.197
            foot1.position.y=0.5
            foot1.position.z=12.1
            chicken.add(foot1)

            //fingers foot
            const finger1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.063,0.060,0.113),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F })
            )
            finger1.position.x=0.132
            finger1.position.y=0.5
            finger1.position.z=11.949
            chicken.add(finger1)

            const finger2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.063,0.060,0.113),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F })
            )
            finger2.position.x=-0.258
            finger2.position.y=0.5
            finger2.position.z=11.949
            chicken.add(finger2)

            const finger3 = new THREE.Mesh(
            new THREE.BoxGeometry(0.063,0.060,0.113),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F })
            )
            finger3.position.x=-0.132
            finger3.position.y=0.5
            finger3.position.z=11.949
            chicken.add(finger3)

            const finger4 = new THREE.Mesh(
            new THREE.BoxGeometry(0.063,0.060,0.113),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F })
            )
            finger4.position.x=0.262
            finger4.position.y=0.5
            finger4.position.z=11.949
            chicken.add(finger4)

            //legs
            const legs1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.075,0.250,0.075),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F })
            )
            legs1.position.x=-0.191
            legs1.position.y=0.654
            legs1.position.z=12.1
            chicken.add(legs1)

            const legs2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.075,0.250,0.075),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F })
            )
            legs2.position.x=0.194
            legs2.position.y=0.654
            legs2.position.z=12.1
            chicken.add(legs2)

            //body

            const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.530,0.420,0.810),
            new THREE.MeshBasicMaterial({ color:0xFFFFFF })
            )
            body.position.x=0.009
            body.position.y=0.991
            body.position.z=12.068
            chicken.add(body)
            

            //head

            const head = new THREE.Mesh(
            new THREE.BoxGeometry(0.530,0.530,0.500),
            new THREE.MeshBasicMaterial({ color:0xFFFFFF })
            )
            head.position.x=0.011
            head.position.y=1.463
            head.position.z=11.94
            chicken.add(head)

            //mouth

            const mouth = new THREE.Mesh(
            new THREE.BoxGeometry(0.150,0.130,0.220),
            new THREE.MeshBasicMaterial({ color:0xFC6F3F })
            )
            mouth.position.x=0.002
            mouth.position.y=1.445
            mouth.position.z=11.562
            chicken.add(mouth)

            const mouth1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.130,0.130,0.130),
            new THREE.MeshBasicMaterial({ color:0xEF3146 })
            )
            mouth1.position.x=0.001
            mouth1.position.y=1.317
            mouth1.position.z=11.608
            chicken.add(mouth1)

            //eyes

            const eye1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.070,0.070,0.070),
            new THREE.MeshBasicMaterial({ color:0x000000 })
            )
            eye1.position.x=0.247
            eye1.position.y=1.591
            eye1.position.z=11.825
            chicken.add(eye1)

            const eye2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.070,0.070,0.070),
            new THREE.MeshBasicMaterial({ color:0x000000 })
            )
            eye2.position.x=-0.221
            eye2.position.y=1.591
            eye2.position.z=11.825
            chicken.add(eye2)

            //wings 

            const wing1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.060,0.230,0.430),
            new THREE.MeshBasicMaterial({ color:0xD6D6D6})
            )
            wing1.position.x=-0.283
            wing1.position.y=0.986
            wing1.position.z=12.066
            chicken.add(wing1)

            const wing2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.060,0.230,0.430),
            new THREE.MeshBasicMaterial({ color:0xD6D6D6})
            )
            wing2.position.x=0.309
            wing2.position.y=0.986
            wing2.position.z=12.066
            chicken.add(wing2)

            //rear 

            const rear = new THREE.Mesh(
            new THREE.BoxGeometry(0.430,0.230,0.060),
            new THREE.MeshBasicMaterial({ color:0xD6D6D6})
            )
            rear.position.x=0.009
            rear.position.y=1.042
            rear.position.z=12.501
            chicken.add(rear)

            //upHead

            const upHead = new THREE.Mesh(
            new THREE.BoxGeometry(0.080,0.070,0.220),
            new THREE.MeshBasicMaterial({ color:0xEF3146 })
            )
            upHead.position.x=0.008
            upHead.position.y=1.754
            upHead.position.z=11.942
            chicken.add(upHead)
            

            scene.add(chicken)
            
            // trees

            // set coolrs tree 
            const colorBrownTree = new THREE.Color(0x412320);
            const colorGreenTree = new THREE.Color(0x85B120);

            const tree1=[]
            
            // TRUNK: 1st geometry
            const trunk1 = new THREE.BoxGeometry(0.750, 1.0, 0.750);
            trunk1.translate(-8.722,0.544,-11.624)
            
            // LEVEL1: 2nd geometry
            const levelTree1 = new THREE.BoxGeometry(1.560, 1.900, 1.320);
            levelTree1.translate(-8.764, 1.948, -11.646); // translate the geometry


            const colorsTrunkS = [];
            for (let i = 0; i < trunk1.attributes.position.count; i++)
                colorsTrunkS.push(colorBrownTree.r, colorBrownTree.g, colorBrownTree.b);

            trunk1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkS), 3));

            const colorsLeavesS = [];
            for (let i = 0; i < levelTree1.attributes.position.count; i++)
                colorsLeavesS.push(colorGreenTree.r, colorGreenTree.g, colorGreenTree.b);

            levelTree1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesS), 3));
            tree1.push(trunk1)
            tree1.push(levelTree1)

            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry = BufferGeometryUtils.mergeBufferGeometries(tree1);
            const Tree = new THREE.Mesh(TreeGeometry,
                    new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree)

            const tree2=[]
            
            // TRUNK: 1st geometry
            const trunk2 = new THREE.BoxGeometry(0.750, 1.710, 0.750);
            trunk2.translate(1.881,0.881,-11.598)
            tree2.push(trunk2)
            // LEVEL1: 2nd geometry
            const levelTree2 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree2.translate(1.870, 3.794, -11.580); // translate the geometry
            tree2.push(levelTree2)

            const colorsTrunkB = [];
            for (let i = 0; i < trunk2.attributes.position.count; i++)
                colorsTrunkB.push(colorBrownTree.r, colorBrownTree.g, colorBrownTree.b);

            trunk2.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            const colorsLeavesB = [];
            for (let i = 0; i < levelTree2.attributes.position.count; i++)
                colorsLeavesB.push(colorGreenTree.r, colorGreenTree.g, colorGreenTree.b);

            levelTree2.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry2 = BufferGeometryUtils.mergeBufferGeometries(tree2);
            const Tree2 = new THREE.Mesh(TreeGeometry2,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree2)

            const tree3=[]
            
            // TRUNK: 1st geometry
            const trunk3 = new THREE.BoxGeometry(0.750,1.000, 0.750);
            trunk3.translate(-9.051,0.457,0.000)
            tree3.push(trunk3)
            // LEVEL1: 2nd geometry
            const levelTree3 = new THREE.BoxGeometry(1.560, 1.900, 1.320);
            levelTree3.translate(-9.030, 1.785, 0.000); // translate the geometry

            trunk3.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkS), 3));
            
            levelTree3.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesS), 3));

            tree3.push(levelTree3)
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry3 = BufferGeometryUtils.mergeBufferGeometries(tree3);
            const Tree3 = new THREE.Mesh(TreeGeometry3,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree3)


            const tree4=[]
            
            // TRUNK: 1st geometry
            const trunk4 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk4.translate(3.330,0.873,0.000)
            tree4.push(trunk4)
            // LEVEL1: 2nd geometry
            const levelTree4 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree4.translate(3.383, 3.852, 0.037); // translate the geometry
            tree4.push(levelTree4)

            trunk4.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree4.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry4 = BufferGeometryUtils.mergeBufferGeometries(tree4);
            const Tree4 = new THREE.Mesh(TreeGeometry3,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree4)


            const tree5=[]
            
            // TRUNK: 1st geometry
            const trunk5 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk5.translate(9.059,0.873,0.000)
            tree5.push(trunk5)
            // LEVEL1: 2nd geometry
            const levelTree5 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree5.translate(9.031, 3.852, 0.000); // translate the geometry
            tree5.push(levelTree5)

            trunk5.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree5.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry5 = BufferGeometryUtils.mergeBufferGeometries(tree5);
            const Tree5 = new THREE.Mesh(TreeGeometry5,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree5)

            const tree6=[]
            
            // TRUNK: 1st geometry
            const trunk6 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk6.translate(-11.261,0.685,11.838)
            tree6.push(trunk6)
            // LEVEL1: 2nd geometry
            const levelTree6 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree6.translate(-11.240, 3.580, 11.810); // translate the geometry
            tree6.push(levelTree6)

            trunk6.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));
            
            levelTree6.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry6 = BufferGeometryUtils.mergeBufferGeometries(tree6);
            const Tree6 = new THREE.Mesh(TreeGeometry6,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree6)

            const tree7=[]
            
            // TRUNK: 1st geometry
            const trunk7 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk7.translate(-6.740,0.901,13.285)
            tree7.push(trunk7)
            // LEVEL1: 2nd geometry
            const levelTree7 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree7.translate(-6.787, 3.796, 13.275); // translate the geometry
            tree7.push(levelTree7)

            trunk7.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree7.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry7 = BufferGeometryUtils.mergeBufferGeometries(tree7);
            const Tree7 = new THREE.Mesh(TreeGeometry7,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree7)

            const tree8=[]
            
            // TRUNK: 1st geometry
            const trunk8 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk8.translate(8.095,0.861,-12.282)
            tree8.push(trunk8)
            // LEVEL1: 2nd geometry
            const levelTree8 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree8.translate(8.060, 3.728, -12.154); // translate the geometry
            tree8.push(levelTree8)

            trunk8.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree8.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry8 = BufferGeometryUtils.mergeBufferGeometries(tree8);
            const Tree8 = new THREE.Mesh(TreeGeometry8,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree8)

            const tree9=[]
            
            // TRUNK: 1st geometry
            const trunk9 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk9.translate(7.212,0.919,12.766)
            tree9.push(trunk9)
            // LEVEL1: 2nd geometry
            const levelTree9 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree9.translate(7.176, 3.834, 12.769); // translate the geometry
            tree9.push(levelTree9)

            trunk9.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree9.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry9 = BufferGeometryUtils.mergeBufferGeometries(tree9);
            const Tree9 = new THREE.Mesh(TreeGeometry9,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree9)


            const tree10=[]
            // TRUNK: 1st geometry
            const trunk10 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk10.translate(-15.259,0.887,0.000)
            tree10.push(trunk10)
            // LEVEL1: 2nd geometry
            const levelTree10 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree10.translate(-15.244, 3.763, 0.000); // translate the geometry
            tree10.push(levelTree10)

            trunk10.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree10.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry10 = BufferGeometryUtils.mergeBufferGeometries(tree10);
            const Tree10 = new THREE.Mesh(TreeGeometry10,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree10)

            const tree11=[]
            // TRUNK: 1st geometry
            const trunk11 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk11.translate(-22.259,0.887,0.000)
            tree11.push(trunk11)
            // LEVEL1: 2nd geometry
            const levelTree11 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree11.translate(-22.244, 3.763, 0.000); // translate the geometry
            tree11.push(levelTree11)

            trunk11.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree11.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry11 = BufferGeometryUtils.mergeBufferGeometries(tree11);
            const Tree11 = new THREE.Mesh(TreeGeometry11,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree11)

            const tree12=[]
            // TRUNK: 1st geometry
            const trunk12 = new THREE.BoxGeometry(0.750,1.710, 0.750);
            trunk12.translate(20.259,0.887,0.000)
            tree12.push(trunk12)
            // LEVEL1: 2nd geometry
            const levelTree12 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree12.translate(20.244, 3.763, 0.000); // translate the geometry
            tree12.push(levelTree12)

            trunk12.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree12.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry12 = BufferGeometryUtils.mergeBufferGeometries(tree12);
            const Tree12 = new THREE.Mesh(TreeGeometry12,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree12)

            const tree13=[]
            
            // TRUNK: 1st geometry
            const trunk13 = new THREE.BoxGeometry(0.750, 1.710, 0.750);
            trunk13.translate(22.881,0.881,-11.598)
            tree13.push(trunk13)
            // LEVEL1: 2nd geometry
            const levelTree13 = new THREE.BoxGeometry(1.960, 4.180, 1.600);
            levelTree13.translate(22.870, 3.794, -11.580); // translate the geometry
            tree13.push(levelTree13)

            trunk13.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunkB), 3));

            levelTree13.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLeavesB), 3));
            
            // 1 merged geometry -> 1 mesh -> 1 single draw call
            const TreeGeometry13 = BufferGeometryUtils.mergeBufferGeometries(tree13);
            const Tree13 = new THREE.Mesh(TreeGeometry13,
                new THREE.MeshBasicMaterial({ vertexColors: true }))
            scene.add(Tree13)


            //wall
            const wallG1 =  new THREE.Group();
            const wall1 = new THREE.Mesh(
            new THREE.BoxGeometry(100.000,-3.720,1.000),
            new THREE.MeshBasicMaterial({ color:0x757575 }),
            )
            wall1.position.x=0
            wall1.position.y=0.667
            wall1.position.z=-14.316
            wallG1.add(wall1)
            scene.add(wallG1)

            const wallG2 =  new THREE.Group();
            const wall2 = new THREE.Mesh(
            new THREE.BoxGeometry(100.000,-3.720,1.000),
            new THREE.MeshBasicMaterial({ color:0x757575 }),
            )
            wall2.position.x=0
            wall2.position.y=0.667
            wall2.position.z=16.033
            wallG2.add(wall2)
            scene.add(wallG2)

            // soft white light
            let light = new THREE.AmbientLight(0x404040);
            // add light to the scene
            scene.add(light); 



            /*************************
            * AXES HELPER
            *************************/
            // show axes for the WORLD CS
            let axes = new THREE.AxesHelper(6);
            scene.add(axes);


            /*****************************
             * RENDER 
             * ***************************/
            // render the scene into viewport using the camera
            function render(){
                
                // camera TO object relative offset
                let relativeOffset = new THREE.Vector3(0, 4, 16);
                // updates the offset with the object’s global transformation matrix
                let cameraOffset = relativeOffset.applyMatrix4(chicken.matrixWorld);
                // updates the camera position with the new offset
                camera.position.copy(cameraOffset)
                // camera looks at the object’s position
                camera.lookAt(chicken.position);
                
                


                renderer.render(scene, camera);
            }
        }

    </script>
</body>

</html>