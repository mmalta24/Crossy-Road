<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Pine Trees</title>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to use the complete page */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <!-- HTML body will hold the Output -->
    <script type="module">
        import * as THREE from './libs/three.module.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';

        let camera, scene, renderer;

        // once everything is loaded, we run our Three.js stuff
        window.onload = function init() {
            /*********************
             * SCENE 
             * *******************/
            // create an empty scene, that will hold all our elements such as objects, cameras and lights
            scene = new THREE.Scene();


            /*********************
             * CAMERA 
             * *******************/
            // create a camera, which defines where we're looking at
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100);
            camera.position.x = 0
            camera.position.y = 12.900;
            camera.position.z = 14.300;
            camera.rotation.set(-32.33,0,0)
            //camera.lookAt(0, 2, 0); //points the camera to world point (0,2,0)


            /*********************
             * RENDERER 
             * *******************/
            // create a render and set the size
            renderer = new THREE.WebGLRenderer({ antialias: false }); // aliasing (jagged edges when rendering)
            renderer.setSize(window.innerWidth, window.innerHeight);
            // configure renderer clear color
            renderer.setClearColor("#444444");

            // add the output of the renderer to an HTML element (this case, the body)
            document.body.appendChild(renderer.domElement);

            //geometries
            const geometries1 = [];
            const geometries2 = [];


            //colors
            const colorBlack = new THREE.Color(0x000000);
            const colorBlue = new THREE.Color(0x001DF5);
            const colorGrey = new THREE.Color(0x616870);
            const colorMatricula = new THREE.Color(0xD6D6D6);




            //RODAS DO CARRO
            const wheel1 = new THREE.CylinderGeometry(0.420, 0.200, 0.400);
            wheel1.translate(3.207,1,4.569)
            //wheel1.rotation.x = 0.1

            const wheel2 = new THREE.CylinderGeometry(0.420, 0.200, 0.400);
            wheel2.translate(3.207,1.040,6.547)
            //wheel1.rotation.x=THREE.Math.degToRad(90)

            const wheel3 = new THREE.CylinderGeometry(0.420, 0.200, 0.400);
            wheel3.translate(0.645,1.040,4.439)
            //wheel1.rotation.x=THREE.Math.degToRad(90)

            const wheel4 = new THREE.CylinderGeometry(0.420, 0.200, 0.400);
            wheel4.translate(0.645,1.040,6.547)
            //wheel1.rotation.x=THREE.Math.degToRad(90)

            //Rodas do atrelado
            const wheel5 = new THREE.CylinderGeometry(0.420, 0.200, 0.400);
            wheel5.translate(-2.647,1.040,6.547)
            //wheel1.rotation.x=THREE.Math.degToRad(90)

            const wheel6 = new THREE.CylinderGeometry(0.420, 0.200, 0.400);
            wheel6.translate(-2.647,1.040,4.439)
            //wheel1.rotation.x=THREE.Math.degToRad(90)


            const colorsWheel = [];
            for (let i = 0; i < wheel1.attributes.position.count; i++){
                colorsWheel.push(colorBlack.r, colorBlack.g, colorBlack.b);
            }
                

            wheel1.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsWheel), 3));

            wheel2.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsWheel), 3));

            wheel3.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsWheel), 3));

            wheel4.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsWheel), 3));
            
            wheel5.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsWheel), 3));
            
            wheel6.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsWheel), 3));
                


            //Cubos do carro
            const cube1 = new THREE.BoxGeometry(4.340, 1.400, 1.960);
            cube1.translate(1.991,1.707,5.533)

            const cube2 = new THREE.BoxGeometry(2.554, 1.250, 1.960);
            cube2.translate(1.627,3.004,5.533)

            //Cubo do atrelado
            const cube3 = new THREE.BoxGeometry(3.220, 1.140, 1.960);
            cube3.translate(-2.493,1.588,5.511)

            const cube4 = new THREE.BoxGeometry(0.120, 0.240, 0.800);
            cube4.translate(-4.076,1.353,5.541)


            //Cores dos cubos
            const colorsCube1 = [];
            for (let i = 0; i < cube1.attributes.position.count; i++){
                colorsCube1.push(colorBlue.r, colorBlue.g, colorBlue.b);
            }

            const colorsCube2 = [];
            for (let i = 0; i < cube2.attributes.position.count; i++){
                colorsCube2.push(colorGrey.r, colorGrey.g, colorGrey.b);
            }

            const colorsCube3 = [];
            for (let i = 0; i < cube3.attributes.position.count; i++){
                colorsCube3.push(colorGrey.r, colorGrey.g, colorGrey.b);
            }

            const colorsCube4 = [];
            for (let i = 0; i < cube4.attributes.position.count; i++){
                colorsCube4.push(colorMatricula.r, colorMatricula.g, colorMatricula.b);
            }

            //Aplicar cubos
            cube1.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsCube1), 3));

            cube2.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsCube2), 3));

            cube3.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsCube3), 3));

            cube4.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsCube4), 3));



            //cilindro do atrelado
            const cld = new THREE.CylinderGeometry(0.090, 0.820, 0.090);
            cld.translate(-0.575,1.511,5.561)
            //cld.rotation.z=THREE.Math.degToRad(90)

            //cor para o cilindro
            const colorsCld = [];
            for (let i = 0; i < cld.attributes.position.count; i++){
                colorsCld.push(colorBlack.r, colorBlack.g, colorBlack.b);
            }

            //Aplicar cilindro
            cld.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsCld), 3));



            //Criar geometria do carro
            geometries1.push(wheel1,wheel2,wheel3,wheel4,cube1,cube2);

            //Criar geometria do atrelado
            geometries2.push(wheel5,wheel6,cube3,cube4,cld);


            //"Create" car
            const carGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries1);
            const car = new THREE.Mesh(
                carGeometry,
                new THREE.MeshBasicMaterial({ vertexColors: true })
            )
            scene.add(car)

            //"Create" atrelado
            const atrGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries2);
            const atr = new THREE.Mesh(
                atrGeometry,
                new THREE.MeshBasicMaterial({ vertexColors: true })
            )
            scene.add(atr)

            /*************************
            * AXES HELPER
            *************************/
            // show axes for the WORLD CS
            let axes = new THREE.AxesHelper(6);
            scene.add(axes);


            /*****************************
             * RENDER 
             * ***************************/
            // render the scene into viewport using the camera
            renderer.render(scene, camera);
        }

    </script>
</body>

</html>